# Deep Analysis: Data Loading Integration Points

## Overview

This analysis identifies all integration points where the app currently uses custom data loading patterns that should be unified to use the centralized `DataProvider` pattern. The goal is to eliminate duplicate data fetching, improve caching, and provide consistent error handling across all features.

## üîç Current Data Loading Patterns

### 1. **Feature-Specific Custom Hooks** (High Priority - Migrate)

#### Birthsigns Feature
- **File**: `src/features/birthsigns/hooks/useBirthsignData.ts`
- **Pattern**: Custom `useReducer` with manual fetch logic
- **Issues**: 
  - Duplicate fetch logic
  - No caching
  - Inconsistent error handling
- **Integration Point**: Replace with `useBirthsigns()` from DataProvider

#### Religions Feature  
- **File**: `src/features/religions/hooks/useReligionData.ts`
- **Pattern**: `useState` + `useEffect` with manual fetch
- **Issues**:
  - Duplicate fetch logic
  - No caching
  - Manual data transformation
- **Integration Point**: Replace with `useReligions()` from DataProvider

#### Skills Feature
- **File**: `src/features/skills/adapters/useSkillData.ts`
- **Pattern**: Complex `useState` + `useEffect` with multiple fetches
- **Issues**:
  - Fetches both skills and perk trees separately
  - Manual perk count computation
  - Complex transformation logic
- **Integration Point**: Replace with `useSkills()` + `usePerkTrees()` from DataProvider

#### Perk Data Feature
- **File**: `src/features/skills/adapters/usePerkData.ts`
- **Pattern**: `useState` + `useEffect` for perk trees
- **Issues**:
  - Duplicate perk tree fetching
  - No caching
- **Integration Point**: Replace with `usePerkTrees()` from DataProvider

### 2. **Static JSON Imports** (Medium Priority - Migrate)

#### Traits Feature
- **File**: `src/features/traits/hooks/useTraits.ts`
- **Pattern**: `import traitData from '../../../../public/data/traits.json'`
- **Issues**:
  - Data bundled with code
  - No runtime updates
  - No caching
- **Integration Point**: Replace with `useTraits()` from DataProvider

#### Races Feature
- **File**: `src/features/races/hooks/useRaces.ts`
- **Pattern**: `import raceData from '../../../../public/data/playable-races.json'`
- **Issues**:
  - Data bundled with code
  - No runtime updates
  - Complex validation logic
- **Integration Point**: Replace with `useRaces()` from DataProvider

### 3. **Page-Level Data Fetching** (High Priority - Migrate)

#### Traits Pages
- **Files**: 
  - `src/features/traits/pages/AccordionTraitsPage.tsx`
  - `src/features/traits/pages/UnifiedTraitsPage.tsx`
- **Pattern**: `useState` + `useEffect` with manual fetch
- **Issues**:
  - Duplicate fetch logic across pages
  - No caching
  - Inconsistent error handling
- **Integration Point**: Replace with `useTraits()` from DataProvider

#### Races Page
- **File**: `src/features/races/pages/AccordionRacesPage.tsx`
- **Pattern**: `useState` + `useEffect` with manual fetch
- **Issues**:
  - Duplicate fetch logic
  - No caching
- **Integration Point**: Replace with `useRaces()` from DataProvider

#### Religions Page
- **File**: `src/features/religions/pages/AccordionReligionsPage.tsx`
- **Pattern**: `useState` + `useEffect` with manual fetch
- **Issues**:
  - Duplicate fetch logic
  - Manual data transformation
- **Integration Point**: Replace with `useReligions()` from DataProvider

### 4. **Custom Data Providers** (Medium Priority - Migrate)

#### Destiny Feature
- **File**: `src/features/destiny/model/DestinyDataProvider.ts`
- **Pattern**: Custom class with manual fetch and caching
- **Issues**:
  - Custom caching logic
  - Inconsistent with centralized pattern
- **Integration Point**: Replace with `useDestinyNodes()` from DataProvider

#### Skills Model
- **File**: `src/features/skills/model/skillData.ts`
- **Pattern**: Pure function with manual fetch
- **Issues**:
  - No caching
  - No error handling
- **Integration Point**: Replace with `useSkills()` from DataProvider

## üéØ Integration Strategy

### Phase 1: High-Impact Features (Week 1)

#### 1.1 Migrate Page-Level Data Fetching
**Priority**: Critical
**Files to Update**:
- `src/features/traits/pages/AccordionTraitsPage.tsx`
- `src/features/traits/pages/UnifiedTraitsPage.tsx`
- `src/features/races/pages/AccordionRacesPage.tsx`
- `src/features/religions/pages/AccordionReligionsPage.tsx`

**Migration Pattern**:
```tsx
// Before
const [traits, setTraits] = useState<Trait[]>([])
const [loading, setLoading] = useState(true)
const [error, setError] = useState<string | null>(null)

useEffect(() => {
  async function fetchTraits() {
    try {
      setLoading(true)
      const res = await fetch(`${import.meta.env.BASE_URL}data/traits.json`)
      if (!res.ok) throw new Error('Failed to fetch trait data')
      const data = await res.json()
      setTraits(data.traits as Trait[])
    } catch (err) {
      setError('Failed to load trait data')
    } finally {
      setLoading(false)
    }
  }
  fetchTraits()
}, [])

// After
const { traits, loading, error } = useTraits()
```

#### 1.2 Migrate Feature-Specific Hooks
**Priority**: Critical
**Files to Update**:
- `src/features/birthsigns/hooks/useBirthsignData.ts`
- `src/features/religions/hooks/useReligionData.ts`
- `src/features/skills/adapters/useSkillData.ts`
- `src/features/skills/adapters/usePerkData.ts`

**Migration Pattern**:
```tsx
// Before
export function useBirthsignData() {
  const [state, dispatch] = useReducer(birthsignDataReducer, initialState)
  // ... complex fetch logic
  return { ...state, refetch: fetchBirthsigns }
}

// After
export function useBirthsignData() {
  const { birthsigns, loading, error, loadBirthsigns } = useBirthsigns()
  
  // Auto-load if not cached
  useEffect(() => {
    if (!loading && birthsigns.length === 0) {
      loadBirthsigns()
    }
  }, [loading, birthsigns.length, loadBirthsigns])
  
  return { birthsigns, loading, error, refetch: loadBirthsigns }
}
```

### Phase 2: Medium-Impact Features (Week 2)

#### 2.1 Migrate Static JSON Imports
**Priority**: High
**Files to Update**:
- `src/features/traits/hooks/useTraits.ts`
- `src/features/races/hooks/useRaces.ts`

**Migration Pattern**:
```tsx
// Before
import traitData from '../../../../public/data/traits.json'

export function useTraits() {
  const traits = useMemo(() => {
    const rawData = (traitData as { traits: Trait[] }).traits
    // ... validation and transformation
    return sanitizedTraits
  }, [])
  // ...
}

// After
export function useTraits() {
  const { traits, loading, error } = useTraits()
  const [filters, setFilters] = useState<TraitFilters>({...})
  
  // Apply filters to cached data
  const filteredTraits = useMemo(() => {
    return traits.filter(trait => {
      // ... filter logic
    })
  }, [traits, filters])
  
  return { traits: filteredTraits, loading, error, filters, setFilters }
}
```

#### 2.2 Migrate Custom Data Providers
**Priority**: Medium
**Files to Update**:
- `src/features/destiny/model/DestinyDataProvider.ts`
- `src/features/skills/model/skillData.ts`

**Migration Pattern**:
```tsx
// Before
export class DestinyDataProvider {
  async loadNodes(): Promise<DestinyNode[]> {
    // ... custom fetch and caching logic
  }
}

// After
export function useDestinyData() {
  const { destinyNodes, loading, error } = useDestinyNodes()
  return { nodes: destinyNodes, loading, error }
}
```

## üîß Implementation Details

### Data Transformation Strategy

#### 1. **ID Generation**
All entities need consistent ID generation:
```tsx
// In DataProvider.ts
const skills = rawData.skills.map((skill: any) => ({
  ...skill,
  id: skill.id || skill.edid || skill.name.toLowerCase().replace(/\s+/g, '-'),
  tags: [...(skill.metaTags || []), skill.category].filter((tag): tag is string => Boolean(tag)),
}))
```

#### 2. **Tag Normalization**
Ensure consistent tag structure:
```tsx
// Common pattern for all entities
tags: [
  entity.category,
  ...(entity.tags || []),
  ...(entity.effects?.map(e => e.type) || [])
].filter((tag): tag is string => Boolean(tag))
```

#### 3. **Type Safety**
Maintain type safety during migration:
```tsx
// Use proper type guards
const isValidEntity = (data: any): data is Entity => {
  return data && typeof data.name === 'string'
}
```

### Error Handling Strategy

#### 1. **Graceful Degradation**
```tsx
// In DataProvider.ts
try {
  const response = await fetch(`${import.meta.env.BASE_URL}data/skills.json`)
  if (!response.ok) throw new Error('Failed to fetch skills data')
  
  const rawData = await response.json()
  // Transform with fallbacks
  const skills = rawData.skills?.map((skill: any) => ({
    ...skill,
    id: skill.id || skill.edid || skill.name?.toLowerCase().replace(/\s+/g, '-') || `skill-${Date.now()}`,
    name: skill.name || 'Unknown Skill',
    description: skill.description || '',
    tags: [...(skill.metaTags || []), skill.category].filter((tag): tag is string => Boolean(tag)),
  })) || []
  
  state.setSkills(skills)
} catch (error) {
  state.setError('skills', error instanceof Error ? error.message : 'Failed to load skills')
  // Set empty array as fallback
  state.setSkills([])
}
```

#### 2. **Retry Logic**
```tsx
// In DataProvider.ts
const loadWithRetry = async (loader: () => Promise<void>, retries = 3) => {
  for (let i = 0; i < retries; i++) {
    try {
      await loader()
      return
    } catch (error) {
      if (i === retries - 1) throw error
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)))
    }
  }
}
```

### Performance Optimization

#### 1. **Selective Re-renders**
```tsx
// Use shallow comparison for Zustand selectors
export const useSkills = () => useDataStore(
  (state) => ({
    skills: state.skills,
    loading: state.loading.skills,
    error: state.errors.skills,
    loadSkills: state.loadSkills,
  }),
  (a, b) => a.skills === b.skills && a.loading === b.loading && a.error === b.error
)
```

#### 2. **Memoized Transformations**
```tsx
// In feature hooks
export function useTraits() {
  const { traits, loading, error } = useTraits()
  const [filters, setFilters] = useState<TraitFilters>({...})
  
  const filteredTraits = useMemo(() => {
    return traits.filter(trait => {
      // ... filter logic
    })
  }, [traits, filters])
  
  return { traits: filteredTraits, loading, error, filters, setFilters }
}
```

## üìä Migration Benefits

### 1. **Performance Improvements**
- **Reduced Network Requests**: Data cached and shared across features
- **Faster Page Loads**: No duplicate data fetching
- **Better User Experience**: Consistent loading states

### 2. **Developer Experience**
- **Consistent Patterns**: Single data loading pattern across all features
- **Type Safety**: Centralized type definitions
- **Error Handling**: Unified error handling and retry logic
- **Debugging**: Centralized logging and monitoring

### 3. **Maintainability**
- **Single Source of Truth**: All data managed in one place
- **Easy Updates**: Data structure changes only need to be made once
- **Testing**: Centralized data loading makes testing easier

### 4. **User Experience**
- **Global Search**: Search across all content types
- **Consistent UI**: Same loading states and error messages
- **Offline Support**: Cached data available offline

## üö® Migration Risks and Mitigation

### 1. **Breaking Changes**
**Risk**: Existing components may break during migration
**Mitigation**: 
- Migrate one feature at a time
- Maintain backward compatibility during transition
- Comprehensive testing after each migration

### 2. **Performance Regression**
**Risk**: Centralized store may cause unnecessary re-renders
**Mitigation**:
- Use selective subscriptions
- Implement proper memoization
- Monitor performance metrics

### 3. **Data Inconsistency**
**Risk**: Different data structures between old and new systems
**Mitigation**:
- Comprehensive data validation
- Fallback mechanisms for missing data
- Gradual migration with dual support

## üìã Migration Checklist

### Phase 1: High-Impact Features
- [ ] Migrate `AccordionTraitsPage.tsx`
- [ ] Migrate `UnifiedTraitsPage.tsx`
- [ ] Migrate `AccordionRacesPage.tsx`
- [ ] Migrate `AccordionReligionsPage.tsx`
- [ ] Migrate `useBirthsignData.ts`
- [ ] Migrate `useReligionData.ts`
- [ ] Migrate `useSkillData.ts`
- [ ] Migrate `usePerkData.ts`

### Phase 2: Medium-Impact Features
- [ ] Migrate `useTraits.ts` (remove static import)
- [ ] Migrate `useRaces.ts` (remove static import)
- [ ] Migrate `DestinyDataProvider.ts`
- [ ] Migrate `skillData.ts`

### Phase 3: Cleanup
- [ ] Remove unused data loading utilities
- [ ] Update documentation
- [ ] Performance testing
- [ ] User acceptance testing

## üéØ Success Metrics

### 1. **Performance Metrics**
- **Network Requests**: Reduce by 70% (from 7+ per page to 1-2)
- **Page Load Time**: Improve by 50% (cached data)
- **Bundle Size**: Reduce by 20% (remove duplicate code)

### 2. **Developer Metrics**
- **Code Duplication**: Reduce by 80%
- **Error Handling**: 100% consistent across features
- **Type Safety**: 100% coverage

### 3. **User Metrics**
- **Search Performance**: Global search across all content
- **Offline Availability**: Cached data available offline
- **Error Recovery**: Graceful handling of data loading failures

## üîÑ Next Steps

1. **Start with Phase 1**: Migrate page-level data fetching first
2. **Test Thoroughly**: Each migration should include comprehensive testing
3. **Monitor Performance**: Track metrics before and after each migration
4. **Document Changes**: Update documentation as features are migrated
5. **Plan Rollback**: Have rollback strategy for each migration phase

This migration will significantly improve the app's architecture, performance, and maintainability while providing a foundation for future features like global search and offline support.
description:
globs:
alwaysApply: false
---
