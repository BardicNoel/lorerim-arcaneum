var m=Object.defineProperty;var d=(l,t,e)=>t in l?m(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var g=(l,t,e)=>d(l,typeof t!="symbol"?t+"":t,e);import{g as w}from"./index-DlgaIZf-.js";class f{static isValid(t){return typeof t=="object"&&t!==null&&typeof t.name=="string"&&typeof t.baseEnchantmentId=="string"&&typeof t.enchantmentType=="string"&&typeof t.targetType=="string"&&["touch","self"].includes(t.targetType)&&Array.isArray(t.effects)&&Array.isArray(t.wornRestrictions)&&Array.isArray(t.foundOnItems)&&typeof t.globalFormId=="string"&&typeof t.plugin=="string"&&typeof t.foundOnItemsTrimmed=="string"}static equals(t,e){return t.baseEnchantmentId===e.baseEnchantmentId}static addComputedProperties(t,e){const s=t.effects.length>0,i=t.effects.length,a=t.targetType==="touch",n=t.targetType==="self",r=t.foundOnItems.length,o=this.generateTags(t,{hasEffects:s,isWeaponEnchantment:a,isArmorEnchantment:n,category:e}),h=this.createSearchableText(t,e);return{...t,hasEffects:s,effectCount:i,isWeaponEnchantment:a,isArmorEnchantment:n,itemCount:r,tags:o,searchableText:h,category:e}}static generateTags(t,e){const s=[];s.push(t.targetType),s.push(e.category),e.hasEffects&&s.push("Has Effects"),e.isWeaponEnchantment&&s.push("Weapon Enchantment"),e.isArmorEnchantment&&s.push("Armor Enchantment");const i=[...new Set(t.foundOnItems.map(a=>a.type))];return s.push(...i),s.push(t.plugin),t.effects.forEach(a=>{s.push(a.name)}),[...new Set(s)]}static createSearchableText(t,e){return[t.name,e,t.plugin,...t.effects.map(i=>`${i.name} ${i.description}`),...t.foundOnItems.map(i=>`${i.name} ${i.type}`),...t.wornRestrictions].join(" ").toLowerCase()}static filterEnchantments(t,e){return t.filter(s=>!(e.categories.length>0&&!e.categories.includes(s.category)||e.targetTypes.length>0&&!e.targetTypes.includes(s.targetType)||e.itemTypes.length>0&&!s.foundOnItems.some(a=>e.itemTypes.includes(a.type))||e.plugins.length>0&&!e.plugins.includes(s.plugin)||e.hasEffects!==null&&s.hasEffects!==e.hasEffects||e.hasWornRestrictions!==null&&s.wornRestrictions.length>0!==e.hasWornRestrictions||e.minItemCount!==null&&s.itemCount<e.minItemCount||e.maxItemCount!==null&&s.itemCount>e.maxItemCount))}static sortEnchantments(t,e,s){return[...t].sort((a,n)=>{let r,o;switch(e){case"name":r=a.name.toLowerCase(),o=n.name.toLowerCase();break;case"category":r=a.category.toLowerCase(),o=n.category.toLowerCase();break;case"targetType":r=a.targetType,o=n.targetType;break;case"plugin":r=a.plugin.toLowerCase(),o=n.plugin.toLowerCase();break;case"itemCount":r=a.itemCount,o=n.itemCount;break;default:r=a.name.toLowerCase(),o=n.name.toLowerCase()}return r<o?s==="asc"?-1:1:r>o?s==="asc"?1:-1:0})}static searchEnchantments(t,e){const s=e.toLowerCase(),i=[];return t.forEach(a=>{let n=0;const r=[];a.name.toLowerCase().includes(s)&&(n+=10,r.push("name")),a.effects.forEach(o=>{o.name.toLowerCase().includes(s)&&(n+=5,r.push("effect")),o.description.toLowerCase().includes(s)&&(n+=3,r.push("effect_description"))}),a.category.toLowerCase().includes(s)&&(n+=4,r.push("category")),a.plugin.toLowerCase().includes(s)&&(n+=2,r.push("plugin")),a.foundOnItems.forEach(o=>{o.name.toLowerCase().includes(s)&&(n+=3,r.push("item"))}),a.tags.forEach(o=>{o.toLowerCase().includes(s)&&(n+=1,r.push("tag"))}),n>0&&i.push({enchantment:a,score:n,matchedFields:[...new Set(r)]})}),i.sort((a,n)=>n.score-a.score)}static getStatistics(t){const e=t.length,s=[...new Set(t.map(c=>c.category))],i=[...new Set(t.map(c=>c.plugin))],a=[...new Set(t.map(c=>c.targetType))],n=[...new Set(t.flatMap(c=>c.foundOnItems.map(p=>p.type)))],r=t.filter(c=>c.hasEffects).length,o=t.filter(c=>c.wornRestrictions.length>0).length,h=e>0?t.reduce((c,p)=>c+p.itemCount,0)/e:0;return{totalEnchantments:e,categories:s.length,plugins:i.length,targetTypes:a.length,itemTypes:n.length,withEffects:r,withRestrictions:o,averageItemCount:Math.round(h*100)/100}}}const u=class u{constructor(){g(this,"cache",null);g(this,"lastFetch",0);g(this,"CACHE_DURATION",5*60*1e3)}static getInstance(){return u.instance||(u.instance=new u),u.instance}async loadEnchantments(){if(this.cache&&Date.now()-this.lastFetch<this.CACHE_DURATION)return this.cache;try{const t=w("data/enchantment-primer.json"),e=await fetch(t);if(!e.ok)throw new Error(`Failed to fetch enchantments: ${e.status} ${e.statusText}`);const s=await e.json(),i=[];let a=0,n=0;for(const r of s.categories)for(const o of r.enchantments)if(f.isValid(o)){const h=f.addComputedProperties(o,r.name);i.push(h),a++}else console.warn("EnchantmentDataProvider: Invalid enchantment data:",o),n++;return this.cache=i,this.lastFetch=Date.now(),i}catch(t){throw t}}async getEnchantmentData(){const t=await this.loadEnchantments(),e=f.getStatistics(t);return{enchantments:t,totalCount:e.totalEnchantments,categoryNames:e.categories,targetTypes:e.targetTypes,plugins:e.plugins,lastUpdated:new Date().toISOString()}}async getEnchantmentByBaseId(t){return(await this.loadEnchantments()).find(s=>s.baseEnchantmentId===t)||null}async getEnchantmentsByCategory(t){return(await this.loadEnchantments()).filter(s=>s.category===t)}async getEnchantmentsByTargetType(t){return(await this.loadEnchantments()).filter(s=>s.targetType===t)}async getEnchantmentsByPlugin(t){return(await this.loadEnchantments()).filter(s=>s.plugin===t)}clearCache(){this.cache=null,this.lastFetch=0}getCacheStatus(){return{hasCache:this.cache!==null,age:this.cache?Date.now()-this.lastFetch:0}}};g(u,"instance");let y=u;export{y as EnchantmentDataProvider};
