import{u as h,a as p,b as v,c as S,d as y,e as w}from"./index-C8Eo6xMn.js";function A(t,e,n){let o=t.health,a=t.stamina,r=t.magicka;if(console.log(`ðŸ”„ [Attribute Transform] Initial points - Health: ${o}, Stamina: ${a}, Magicka: ${r}`),n!=="None"){const i=n.toLowerCase();i==="health"?o+=1:i==="stamina"?a+=1:i==="magicka"&&(r+=1),console.log(`ðŸ”„ [Attribute Transform] Added Oghma choice (${n}) to attribute assignments`)}const s={};let l=2;console.log(`ðŸ”„ [Attribute Transform] Starting assignment creation. Current level: ${l}`);const f=(c,i)=>{console.log(`ðŸ”„ [Attribute Transform] Adding ${i} levels for ${c}`);for(let g=0;g<i;g++)s[l]=c,console.log(`ðŸ”„ [Attribute Transform] Level ${l} assigned to ${c}`),l++};f("health",o),f("stamina",a),f("magicka",r),console.log(`ðŸ”„ [Attribute Transform] After creating assignments. Current level: ${l}, Assignments:`,s);const m=o*5,u=a*5,T=r*5;return console.log("ðŸ”„ [Attribute Transform] GigaPlanner input:",{health:t.health,stamina:t.stamina,magicka:t.magicka,level:e,oghmaChoice:n}),console.log("ðŸ”„ [Attribute Transform] Converted assignments:",{health:m,stamina:u,magicka:T,level:e,assignments:s,totalAssignments:Object.keys(s).length,assignmentKeys:Object.keys(s),assignmentValues:Object.values(s)}),{health:m,stamina:u,magicka:T,level:e,assignments:s}}function D(t){const e=h.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Blessing Transform] Blessings store data not loaded, attempting to load..."),e.load().catch(o=>{console.error("ðŸ”„ [Blessing Transform] Failed to load blessing data:",o)}),null;const n=e.data.find(o=>o.name.toLowerCase()===t.toLowerCase()||o.blessingName.toLowerCase()===t.toLowerCase());return(n==null?void 0:n.id)||null}function $(t){if(t==="Unknown")return null;const e=D(t);return console.log("ðŸ”„ [Blessing Transform] Blessing mapping:",{original:t,mapped:e,dataLoaded:h.getState().data.length>0}),e}function B(t){const e=p.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Destiny Transform] Destiny store data not loaded, attempting to load..."),e.load().catch(a=>{console.error("ðŸ”„ [Destiny Transform] Failed to load destiny data:",a)}),null;const n=t.trim().replace(/\s+/g," ").toLowerCase();console.log("ðŸ”„ [Destiny Transform] Looking for destiny node:",{original:t,normalized:n,availableNodes:e.data.map(a=>a.name).slice(0,5)});const o=e.data.find(a=>a.name.toLowerCase().replace(/\s+/g," ")===n);return o?console.log("ðŸ”„ [Destiny Transform] Found destiny node:",{original:t,normalized:n,found:o.name,edid:o.edid}):console.warn("ðŸ”„ [Destiny Transform] Destiny node not found:",{original:t,normalized:n,totalNodesAvailable:e.data.length}),(o==null?void 0:o.edid)||null}function E(t){const e=[];return t.forEach(n=>{if(n==="Unknown")return;const o=B(n);o?(e.push(o),console.log("ðŸ”„ [Destiny Transform] Destiny mapping:",{original:n,mapped:o,dataLoaded:p.getState().data.length>0})):console.warn(`ðŸ”„ [Destiny Transform] Unknown destiny node: ${n}`)}),e}function F(t){var n;const e=v.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Perk Transform] Perk trees store data not loaded, attempting to load..."),e.load().catch(o=>{console.error("ðŸ”„ [Perk Transform] Failed to load perk trees data:",o)}),null;for(const o of e.data){const a=(n=o.perks)==null?void 0:n.find(r=>r.name.toLowerCase()===t.toLowerCase());if(a)return{edid:a.edid,skillTree:o.treeId}}return null}function G(t,e){console.log("ðŸ”„ [Perk Transform] Starting perk transformation..."),console.log("ðŸ”„ [Perk Transform] Input perks:",t),console.log("ðŸ”„ [Perk Transform] Perk list name:",e);const n={},o=[];return t.forEach((a,r)=>{if(console.log(`ðŸ”„ [Perk Transform] Processing perk ${r}:`,{name:a.name,skill:a.skill,skillType:a.skill==="Destiny"?"subclass":a.skill==="Traits"?"trait":"regular"}),a.skill==="Destiny"){console.log("ðŸ”„ [Perk Transform] Found subclass:",a.name);return}else if(a.skill==="Traits"){console.log("ðŸ”„ [Perk Transform] Found trait:",a.name);return}const s=F(a.name);s?(n[s.skillTree]||(n[s.skillTree]=[]),n[s.skillTree].push(s.edid),console.log(`ðŸ”„ [Perk Transform] Added perk to skill ${s.skillTree}:`,{originalName:a.name,foundEdid:s.edid,skillTree:s.skillTree})):(o.push(`Could not find perk in store: ${a.name}`),console.log(`ðŸ”„ [Perk Transform] Warning: Could not find perk in store: ${a.name}`))}),console.log("ðŸ”„ [Perk Transform] Final results:",{inputCount:t.length,regularCount:t.filter(a=>a.skill!=="Destiny"&&a.skill!=="Traits").length,subclassCount:t.filter(a=>a.skill==="Destiny").length,traitCount:t.filter(a=>a.skill==="Traits").length,groupedCount:Object.keys(n).length,warnings:o.length,groupedPerks:n}),Object.keys(n).length===0?(console.log("ðŸ”„ [Perk Transform] No regular perks found, returning null"),null):{selected:n,ranks:{}}}function P(t){const e=t.filter(n=>n.skill==="Destiny").map(n=>n.name);return console.log("ðŸ”„ [Subclass Extract] Found subclasses:",e),e}function U(t){const e=t.filter(n=>n.skill==="Traits").map(n=>n.name);return console.log("ðŸ”„ [Trait Extract] Found traits:",e),e}function C(t){const e=S.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Race Transform] Race store data not loaded, attempting to load..."),e.load().catch(o=>{console.error("ðŸ”„ [Race Transform] Failed to load race data:",o)}),null;const n=e.data.find(o=>o.name.toLowerCase()===t.toLowerCase());return(n==null?void 0:n.edid)||null}function O(t){if(t==="Unknown")return null;const e=C(t);return console.log("ðŸ”„ [Race Transform] Race mapping:",{original:t,mapped:e,dataLoaded:S.getState().data.length>0}),e}function j(t){const e={};return t.forEach(n=>{n.skill!=="Level"&&(e[n.skill]=n.level)}),console.log("ðŸ”„ [Skill Transform] Skill levels:",{count:Object.keys(e).length,skills:Object.keys(e)}),e}function z(t){const e=y.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Stone Transform] Birthsign store data not loaded, attempting to load..."),e.load().catch(o=>{console.error("ðŸ”„ [Stone Transform] Failed to load birthsign data:",o)}),null;const n=e.data.find(o=>o.name.toLowerCase()===t.toLowerCase());return(n==null?void 0:n.edid)||null}function x(t){if(t==="Unknown")return null;const e=z(t);return console.log("ðŸ”„ [Stone Transform] Stone mapping:",{original:t,mapped:e,dataLoaded:y.getState().data.length>0}),e}function N(t){const e=w.getState();if(e.data.length===0)return console.warn("ðŸ”„ [Trait Transform] Traits store data not loaded, attempting to load..."),e.load().catch(a=>{console.error("ðŸ”„ [Trait Transform] Failed to load trait data:",a)}),null;const n=t.trim().replace(/\s+/g," ").toLowerCase();console.log("ðŸ”„ [Trait Transform] Looking for trait:",{original:t,normalized:n,availableTraits:e.data.map(a=>a.name).slice(0,5)});const o=e.data.find(a=>a.name.toLowerCase().replace(/\s+/g," ")===n);return o?console.log("ðŸ”„ [Trait Transform] Found trait:",{original:t,normalized:n,found:o.name,edid:o.edid}):console.warn("ðŸ”„ [Trait Transform] Trait not found:",{original:t,normalized:n,totalTraitsAvailable:e.data.length}),(o==null?void 0:o.edid)||null}function R(t){const e=[],n=[];return t.forEach(o=>{if(o==="Unknown")return;const a=N(o);a?(e.push(a),console.log("ðŸ”„ [Trait Transform] Trait mapping:",{original:o,mapped:a,dataLoaded:w.getState().data.length>0})):console.warn(`ðŸ”„ [Trait Transform] Unknown trait: ${o}`)}),{regular:e,bonus:n}}async function H(t){try{const e=[];console.log("ðŸ”„ [GigaPlanner Transform] Ensuring store data is loaded...");const n=S.getState();n.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading race data..."),await n.load());const o=y.getState();o.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading birthsign data..."),await o.load());const a=h.getState();a.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading blessing data..."),await a.load());const r=w.getState();r.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading traits data..."),await r.load());const s=p.getState();s.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading destiny data..."),await s.load());const l=v.getState();l.data.length===0&&(console.log("ðŸ”„ [GigaPlanner Transform] Loading perk trees data..."),await l.load());const f=O(t.race);t.race!=="Unknown"&&!f&&e.push(`Unknown race: ${t.race}`);const m=x(t.standingStone);t.standingStone!=="Unknown"&&!m&&e.push(`Unknown standing stone: ${t.standingStone}`);const u=$(t.blessing),T=A(t.hmsIncreases,t.level,t.oghmaChoice),c=j(t.skillLevels),i=G(t.perks,t.configuration.perkList),g=U(t.perks);console.log("ðŸ”„ [GigaPlanner Transform] Extracted trait names:",g);const b=g.length>0?R(g):{regular:[],bonus:[]};console.log("ðŸ”„ [GigaPlanner Transform] Transformed traits:",b);const k=P(t.perks);console.log("ðŸ”„ [GigaPlanner Transform] Extracted subclass names:",k);const L=k.length>0?E(k):[];console.log("ðŸ”„ [GigaPlanner Transform] Transformed destiny path:",L);const d={race:f,stone:m,favoriteBlessing:u,attributeAssignments:T,skillLevels:Object.keys(c).length>0?c:void 0,perks:i||void 0,traits:b,destinyPath:L};return console.log("ðŸ”„ [GigaPlanner Transform] Final build state:",{race:d.race,stone:d.stone,favoriteBlessing:d.favoriteBlessing,perks:d.perks,traits:d.traits,destinyPath:d.destinyPath,skillLevels:d.skillLevels}),{success:!0,data:d,warnings:e.length>0?e:void 0}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown transformation error"}}}export{H as transformGigaPlannerToBuildState};
